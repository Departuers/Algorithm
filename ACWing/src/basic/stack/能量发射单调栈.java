package basic.stack;

import java.util.Scanner;

/**
 * https://www.cnblogs.com/gzh-red/p/11019265.html
 * https://www.acwing.com/blog/content/132/
 * 第二题
 * 题目描述
 * 某地有 N 个能量发射站排成一行，每个发射站 i 都有不相同的高度 Hi
 * ，并能向两边（当然两端的只能向一边）同时发射能量值为 Vi
 * 的能量，并且发出的能量只被两边最近的且比它高的发射站接收。
 * 显然，每个发射站发来的能量有可能被 0 或 1 或 2 个其他发射站所接受，出于安全考虑，每个发射站接收到的能量总和是我们很关心的问题。
 * 由于数据很多，现在只需要你帮忙计算出接收最多能量的发射站接收的能量是多少。
 * 输入格式
 * 第一行包含整数N。
 * 接下来N行，每行包含两个整数Hi
 * 和Vi
 * ，其中第 i 行的数据为第 i 个发射站的高度和能量值。
 * 输出格式
 * 输出仅一行，表示接收最多能量的发射站接收到的能量值。
 * 数据保证答案不超过231−1
 * 数据范围
 * 1≤N≤106
 * ,
 * 1≤Hi≤2∗109,
 * 1≤Vi≤10000
 * <p>
 * 输入样例：
 * <p>
 * Copy
 * 3
 * 4 2
 * 3 5
 * 6 10
 * <p>
 * 输出样例：
 * <p>
 * Copy
 * 7
 * 数据结构
 * 既然现在我们已经想到了数据结构来优化算法,那么现在当前最大的问题.无非就是如何利用这个我们学过数据结构来优化这道题目.
 * 我们发现这道题目,所有的数字都满足一个非常重要的性质,那就是发出的能量只被两边最近的且比它高的发射站,我们从中间,不但会发现这道题目的条件,还会发现这道题目出题人,偷偷告诉我们的性质.那就是两边最近且比他高.
 * 性质分析
 * 两边最近: 显然,是一个条件&性质,而且这里面最为重要的性质核心,就是最近这个两个字.
 * 看到这里,我们就得让神经系统中的神经元,条件反射地想到,是不是需要后进后出的数据结构栈
 * 比他高: 这就是这道题目的第二大精髓思想,单调性,我们通过这道题目的这句话,可以敏锐地察觉到,这道题目需要使用具有单调性质的单调栈.
 * 算法步骤
 * 这道题目既然是需要使用具有非常秀的单调栈,那么我们到底如何使用呢?
 * 那么此时我们就需要根据条件,来确定单调栈,插入栈顶的条件.
 * 因为对于一个发射站而言,它可以接收到的能量,就是一组单调递减的高度序列的能量.这里我们需要画图解决问题.
 * 综上所述,我们可以开一个单调递减的栈,统计所有高度单调递减的发射站.
 * 1. 如果当前这个数字破坏了单调递减,那么它会挡掉比它矮的所有发射站.
 * 然后将所有比它能量小的发射站,统统吸取.然后将这些发射站出栈,自己入栈.
 * 2. 如果当前发射站,满足单调递减的话,那么栈顶所属的发射站,吸取它的能量.同样自己也需要入栈
 */
public class 能量发射单调栈 {

    static class node {
        public int x = 0, y = 0;

        public node(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        for (int i = 1; i <= n; i++) {
            a[i] = sc.nextInt();
            b[i] = sc.nextInt();
        }
        st[++top] = new node(a[1], 1);
        for (int i = 2; i <= n; i++) {
            while (top != 0 && a[i] > st[top].x) {//0位置没有元素
                // 这样写不会空指针
                s[i] += b[st[top--].y];
            }
            if (top != 0)
                s[st[top].y] += b[i];
            st[++top] = new node(a[i], i);
        }
        int res = 0;
        for (int i = 1; i <= n; i++) {
            res = Math.max(res, s[i]);
        }
        System.out.println(res);
    }

    private static int[] s = new int[100005];//结果
    static node[] st = new node[100000];//看做栈
    static int top = 0;//看做栈指针
    static int[] a = new int[100005], b = new int[100005];

}
