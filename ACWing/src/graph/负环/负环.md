###负环
````
存在一个环,其边权之和小于0
只要一个点可以走到负环上,可以在负环上走无穷次,
某一些点使得权值和为无穷小

01分数规划

求负环的常见方法基于spfa
1.统计每个点入队的次数,如果某个点入队n次,说明存在负环
一共只有n个点,1->2->3->...->n
如果有一条路径n条边,那么就经过了n+1个点,其中一定有两个点是相同的
表示其中存在环.

类似于BellmanFord
最差O(n^2)

推荐2.统计当前每个点的最短路中所包含的边数,
显然 只需要在求最短路里面加一条 cnt[j]=cnt[t]+1;

如果某个点的最短路所包含的边数大于等于n,
则也说明存在环
O(n)推荐

考虑到:由t拓展j
cnt[j]=cnt[t]+1
if(cnt[j]>n)存在负环
统计每个点最短路包含的边数,如果某个点的最短路中包含负环,说明存在环

考虑1~n组成负环,n个点连起来组成的负环,每个点入队n(n-1)+1次才能判断出负环的存在
第一种做法是O(n^2) n(n-1)+1次
第二种做法,入队n次就直接判断出负环了

考虑1号点,不和其他点连通,但2->3->4->2存在负环
所以要把所有点加入队列

初始化,queue加入所有节点,看做超级源点连接每个点权值都为0
第一次迭代,把超级源点都加入队列
第二次迭代,超级源点拓展,把所有的点都加入队列
初始化,queue加入所有节点,等价于,建立超级源点,到所有点的距离为0

为什么dis初始化为0
存在负环等价于使得dis[i]=负无穷,
任意边权都是有限值,不管初始值赋值是什么,都是有限值,
会更新无限次,有限值-有限值 然而结果为负无穷,必然减了无限次
因为如果有负环,dis赋值为有限值,一直减结果必然会变成负无穷

只有BellmanFord 和Floyd才有 0x3f3f3f3f/2

spfa判断环,把队列换成栈跑的更快

经验之谈,trick
当所有点的入队次数超过2n的时候,我们就认为图中很大可能存在负环,
