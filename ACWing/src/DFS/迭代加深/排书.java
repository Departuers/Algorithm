package DFS.迭代加深;

import java.util.Scanner;

/**
 * https://blog.csdn.net/qq_30277239/article/details/105767056
 * 给定n本书，编号为1-n。
 * 在初始状态下，书是任意排列的。
 * 在每一次操作中，可以抽取其中连续的一段，再把这段插入到其他某个位置。
 * 我们的目标状态是把书按照1-n的顺序依次排列。
 * 求最少需要多少次操作。
 * 输入格式
 * 第一行包含整数T，表示共有T组测试数据。
 * 每组数据包含两行，第一行为整数n，表示书的数量。
 * 第二行为n个整数，表示1-n的一种任意排列。
 * 同行数之间用空格隔开。
 * 输出格式
 * 每组数据输出一个最少操作次数。
 * 如果最少操作次数大于或等于5次，则输出”5 or more”。
 * 每个结果占一行。
 * 数据范围
 * 1≤n≤15
 * 输入样例：
 * 3
 * 6
 * 1 3 4 6 2 5
 * 5
 * 5 4 3 2 1
 * 10
 * 6 8 5 3 4 7 2 9 1 10
 * 输出样例：
 * 2
 * 3
 * 5 or more
 * 分析：
 * 本题可以使用双向DFS或者IDA*解决。IDA*就是将A*算法应用于迭代加深算法中，
 * 准确说只是用到了A*算法的估价函数。
 * 首先考虑本题的状态数，对于一个长度为n的序列，选取其中一段移动到另一个位置，
 * 选取的长度可能是1到n - 1。选取长度为1时，选第一个元素有n - 1种移动方法，
 * 选第二个元素有n - 2个移动方法，...，长度为1的情况就一共有n - 1 + n - 2 + ... + 1中方法去移动；
 * 长度为2时一共n - 2 + ... + 1种方法，长度为n - 1时一共1种移动方法，
 * 总的移动方法有S = n - 1 + 2 * (n-2) + 3 * (n - 3) + ... + (n - 1) * 1 = （n + 2n + 3n + ... (n-1)n） - (1 + 4 + 9 + (n - 1)^2) = (n-1)n*n / 2 - n(n-1)(2n-1) / 6 = n(n-1)(n+1) / 6，当n = 15时，14 * 15 * 16 / 6 = 960。要想搜四层状态，就要搜索接近1000^4这么多种状态，显然无法承受，所以可以双向DFS将状态数降低到1000^2级别。使用IDA*则能够更快的解决问题。
 * 我们知道，估价函数的值是不会超过当前状态离目标状态的真实距离的，所以一旦已搜索的深度u加上估价函数的值超过了设定的深度，
 * 就不必继续搜索了。如果每次只能移动一个元素，我们可以用每个元素离最终位置的距离作为估价函数，但是现在是批量移动元素。
 * 比如1 2 3 4 5，将2 3移动到4的后面得到1 4 2 3 5，可以发现1的后继、4的后继、3的后继都改变了，而其它元素的后继未变，
 * 实际上，每次移动最多能改变三个元素的后继，所谓的后继就是这个元素的下一个元素。我们要实现的最终状态是每个元素的后继都比当前元素多1，
 * 就说明有序了。设估价函数为错误后继的对数，注意这里的错误后继与逆序对并不是一个概念。只要一个元素的后一个元素不是比它大1的元素，
 * 就应该记入错误后继。既然因此移动只能改变3个元素的后继，那么当前错误后继对数为cnt时，至少需要cnt / 3上取整次移动才能将序列恢复为有序。
 * 估价函数f就等于(cnt + 2) / 3，这里加上2是为了上取整。
 * 下面要做的，就是在dfs里枚举每次取的序列的长度，起点位置以及移动到哪个位置后，比如 1 2 3 4 5，长度为1时，起点是下标为0的位置，也就是元素1，
 * 将它移动到下标为3的后面就得到了2 3 4 1 5,。长度为1的序列移动规律可能不太明显，
 * 来看个更长的序列，1 2 3 4 5 6 7 8移动2 3 4到6的后面得到1 5 6 2 3 4 7 8，可以发现只是将2 3 4右移了2个位置。
 * 这里我使用了一种常见的移动元素的策略，就是先将2 3 4反转，再将5 6反转，最后将这个5个元素所在区间的所有元素反转，
 * 即1 2 3 4 5 6 7 8到1 4 3 2 5 6 7 8到1 4 3 2 6 5 7 8到1 5 6 2 3 4 7 8，也就实现了将序列右移的目的。
 * 另外，需要注意的是，每次dfs后要恢复数列的状态，需要用个备份数组back，
 * 而且由于back是全局变量，所以不同深度的dfs必须使用不同的back，否则就会出错，因此back定义为二维数组。
 */
public class 排书 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        T = sc.nextInt();
        while (T-- != 0) {
            n = sc.nextInt();
            for (int i = 0; i < n; i++) {
                q[i] = sc.nextInt();
            }
            int depth = 0;
            while (depth < 5 && !dfs(0, depth)) depth++;
            if (depth >= 5) System.out.println("5 or more");
            else System.out.println(depth);
        }
    }

    private static boolean dfs(int depth, int max_depth) {
        if (depth + f() > max_depth)
            return false;
        if (f() == 0) return true;
        for (int len = 1; len <= n; len++) {
            for (int l = 0; l + len <= n; l++) {
                int r = l + len - 1;
                for (int k = r + 1; k < n; k++) {
                }
            }
        }
        return false;
    }

    static int f() {
        int tot = 0;
        for (int i = 0; i + 1 < n; i++) {
            if (q[i + 1] != q[i] + 1)
                tot++;
        }
        return (tot + 2) / 3;
    }

    static int N = 15, T, n;
    static int[][] w = new int[5][N];
    static int[] q = new int[N];

}
