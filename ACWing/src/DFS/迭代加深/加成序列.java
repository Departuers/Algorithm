package DFS.迭代加深;

import java.util.*;

/**
 * https://blog.csdn.net/qq_30277239/article/details/105752519
 * 迭代加深,虽然会重复搜,但层数非常深,但使用bfs内存不够,所以使用迭代加深
 * 满足如下条件的序列X（序列中元素被标号为1、2、3…m）被称为“加成序列”：
 * 1、X[1]=1
 * 2、X[m]=n
 * 3、X[1]<X[2]<…<X[m-1]<X[m]
 * 4、对于每个 kk（2≤k≤m）都存在两个整数 ii和 jj （1≤i,j≤k−1 i 和 j 可相等），使得X[k]=X[i]+X[j]。
 * 你的任务是：给定一个整数n，找出符合上述条件的长度m最小的“加成序列”。
 * 如果有多个满足要求的答案，只需要找出任意一个可行解。
 * 输入格式
 * 输入包含多组测试用例。
 * 每组测试用例占据一行，包含一个整数n。
 * 当输入为单行的0时，表示输入结束。
 * 输出格式
 * 对于每个测试用例，输出一个满足需求的整数序列，数字之间用空格隔开。
 * 每个输出占一行。
 * 数据范围
 * 1≤n≤100
 * <p>
 * 输入样例：
 * 5
 * 7
 * 12
 * 15
 * 77
 * 0
 * 输出样例：
 * 1 2 4 5
 * 1 2 4 6 7
 * 1 2 4 8 12
 * 1 2 4 5 10 15
 * 1 2 4 8 9 17 34 68 77
 * 分析：
 * 本题要使用迭代加深去求解。当搜索树中存在较深的分支而解可能在较浅的节点时，
 * 可以提前设定搜索树的最大深度，一旦搜索的深度超过了设定值，便不再沿这个方向搜索下去。
 * 如果当前设定的深度未搜索到解，就加大深度继续搜索，直到搜索到解为止。
 * 剪枝：首先优化搜索顺序，当前搜索的节点可能是前面的两个节点之和，为了尽快的逼近n，
 * 我们从大到小去枚举之前的元素，以减少分支数量。排除等效冗余，枚举第cur个位置上的数时，
 * 是在枚举前面两个元素的和，而前面任两个数的和可能有重复，比如1 2 3 4，
 * 枚举下一个位置时2 + 3和1 + 4都是5。1 2 3 4 5这个序列只需要枚举一次就好，
 * 所以需要设置标志数组，不去搜索重复的节点。可行性剪枝，当枚举的第cur个数大于n或者比第cur - 1个数小时，不进行搜索。
 * 构造序列
 * <p>
 * 第一个数只能是1,第二个数只能是2
 * 后面的数可以是序列前面中任选的两个数相加
 * 剪枝优化:
 * 1. 优化搜索顺序:从大到小来枚举下一个数
 * 比如第3个可能是3或4,先枚举4,从大到小
 * 2. 排除等效冗余
 * 枚举一个数有组合数Cn2+n种选择,其中n代表序列前面的数,不同两个数的和可能是一样的,枚举过了,就不再枚举这个数
 */
public class 加成序列 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        path[0] = 1;

        while (sc.hasNext()) {
            n = sc.nextInt();
            if (n == 0) break;
            int depth = 1;
            while (!dfs(1, depth)) {
                depth++;
            }
            for (int i = 0; i < depth; i++) {
                System.out.print(path[i] + " ");
            }
            System.out.println();
        }
    }

    /**
     * path 可以记录递归的路径
     *
     * @param u     当前有几个元素
     * @param depth 深度
     * @return 是否成功
     */
    static boolean dfs(int u, int depth) {
        if (u > depth) return false;//超过深度
        if (path[u - 1] == n) return true;//显然,是到下一层递归判断上一层结果对不对,所以是u-1,最后一个数等于要求的数
        Arrays.fill(st, false);//在一层里面不能枚举相同元素,

        //显然每一层,可能整出
        for (int i = u - 1; i >= 0; i--) {//从大到小
            for (int j = i; j >= 0; j--) {//枚举组合数,顺序无关
                //上面循环看出,是已知序列的最右边元素开始枚举和
                int s = path[i] + path[j];
                if (s > n || s < path[u - 1] || st[s]) continue;
                //超过了n,更新的数比前一个数还更小了,已经出现过这个数,跳过

                st[s] = true;
                path[u] = s;
                if (dfs(u + 1, depth)) return true;//连锁反应
            }
        }
        return false;
    }

    static int[] path = new int[110];
    static int n;
    static boolean[] st = new boolean[110];

}
