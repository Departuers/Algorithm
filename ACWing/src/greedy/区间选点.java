package greedy;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner;

/**
 * 给定N个闭区间[ai,bi]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。
 * 输出选择的点的最小数量。位于区间端点上的点也算作区间内。
 * 输入格式
 * 第一行包含整数N，表示区间数。
 * 接下来N行，每行包含两个整数ai,bi，表示一个区间的两个端点。
 * 输出格式
 * 输出一个整数，表示所需的点的最小数量。
 * 数据范围
 * 1≤N≤10^5,
 * −10^9≤ai≤bi≤10^9
 * 输入样例：
 * 3
 * -1 1
 * 2 4
 * 3 5
 * 输出样例：
 * 2
 * <p>
 * 本题是区间贪心的经典题，要求选出尽可能少的点，使得所有区间都有包含的点。
 * 相当于给学生发书，每个人有空的时间是一段区间，要求尽可能少的选择若干个时间点，
 * 将书发放给所有的学生。这类贪心问题一般按照所有区间的右端点从小到大排序，
 * 然后选择按照右端点自小到大的遍历区间，如果某个区间内没有选择点，则选择区间的右端点。
 * 比如按照区间右端点排序得到[1,3],[2,5],[4,6]，第一个点选择3，
 * 然后判断下第二个区间是否包含3，由于第二个区间右端点是大于3的，
 * 只需要左端点小于3便与第一个区间有了交集，即[l1,r1],[l2,r2]，有r1 < r2；
 * 当l2 < r1时两个区间有交集，且第一个区间右端点r1必然在两个区间交集内。2 < 3，
 * 所以第二个区间包含3，故遍历到下一个区间[4,6]，4 > 3，所以不包含3，选择第二个点6。
 * 至于为什么对右端点自小到大排序后每次要选择右端点，
 * 因为如果两个区间有交集，右端点较小的那个区间的右端点必然处于两个区间的交集内。
 * 下面证明这样选择的点是最少的。我们知道，
 * 每次需要选择一个新的点的时候都有当前遍历到区间的左端点大于上一个被选择区间的右端点，
 * 即有多少个点被选择，原来的区间集合就存在多少个互不相交的区间，因此，这样选择的点数是最少的。
 * 排序推测...
 * <p>
 * <p>
 * 给定N个闭区间[ai,bi]，请你在数轴上选择若干区间，使得选中的区间之间互不相交（包括端点）。
 * 输出可选取区间的最大数量。
 * 输入格式
 * 第一行包含整数N，表示区间数。
 * 接下来N行，每行包含两个整数ai,bi，表示一个区间的两个端点。
 * 输出格式
 * 输出一个整数，表示可选取区间的最大数量。
 * 数据范围
 * 1≤N≤10^5,
 * −10^9≤ai≤bi≤10^9
 * 输入样例：
 * 3
 * -1 1
 * 2 4
 * 3 5
 * 输出样例：
 * 2
 * 同解
 * 在AcWing 905 区间选点中，我们证明了将区间按照右端点排序，
 * 然后选择不相交的区间的右端点，可以使得所有区间都至少包含了一个选择出来的点。
 * 即被选择出来多少个点，原区间集合就有多少个不相交的区间，设选择出来ans个点，
 * 可以证明区间集合中有ans个不相交的区间。如果原区间集合中存在res个不相交的区间，
 * 且res > ans，则至少应该有res个点才能使得各个区间都包含了被选择的点，
 * 但是已经选出了ans个点足以使得所有区间内都有被选择的点，
 * 说明区间集合内不存在res个不相交的区间，即ans是不相交区间的最大数量。
 * 因此，本题代码与上一题代码完全一致，
 * 按区间右端点自小到大排序然后取右端点的贪心策略既可以解决区间选点问题，
 * 也可以解决最大不相交区间问题。
 */
public class 区间选点 {
    static class node implements Comparable<node> {
        int x, y;

        public node(int x, int y) {
            this.x = x;
            this.y = y;
        }

        @Override
        public int compareTo(node node) {
            return y - node.y;
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        for (int i = 0; i < n; i++) {
            e.add(new node(sc.nextInt(), sc.nextInt()));
        }
        Collections.sort(e);
        int u = e.get(0).y;
        int res = 1;
        for (int i = 1; i < n; i++) {
            if (e.get(i).x <= u) continue;
            u = e.get(i).y;
            res++;
        }
        System.out.println(res);
    }

    static ArrayList<node> e = new ArrayList<node>();
    static int n;
}
