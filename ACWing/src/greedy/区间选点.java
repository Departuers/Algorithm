package greedy;

/**
 * 给定N个闭区间[ai,bi]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。
 * 输出选择的点的最小数量。位于区间端点上的点也算作区间内。
 * 输入格式
 * 第一行包含整数N，表示区间数。
 * 接下来N行，每行包含两个整数ai,bi，表示一个区间的两个端点。
 * 输出格式
 * 输出一个整数，表示所需的点的最小数量。
 * 数据范围
 * 1≤N≤10^5,
 * −10^9≤ai≤bi≤10^9
 * 输入样例：
 *     3
 *     -1 1
 *     2 4
 *     3 5
 * 输出样例：
 * 2
 *
 * 本题是区间贪心的经典题，要求选出尽可能少的点，使得所有区间都有包含的点。
 * 相当于给学生发书，每个人有空的时间是一段区间，要求尽可能少的选择若干个时间点，
 * 将书发放给所有的学生。这类贪心问题一般按照所有区间的右端点从小到大排序，
 * 然后选择按照右端点自小到大的遍历区间，如果某个区间内没有选择点，则选择区间的右端点。
 * 比如按照区间右端点排序得到[1,3],[2,5],[4,6]，第一个点选择3，
 * 然后判断下第二个区间是否包含3，由于第二个区间右端点是大于3的，
 * 只需要左端点小于3便与第一个区间有了交集，即[l1,r1],[l2,r2]，有r1 < r2；
 * 当l2 < r1时两个区间有交集，且第一个区间右端点r1必然在两个区间交集内。2 < 3，
 * 所以第二个区间包含3，故遍历到下一个区间[4,6]，4 > 3，所以不包含3，选择第二个点6。
 *
 * 至于为什么对右端点自小到大排序后每次要选择右端点，
 * 因为如果两个区间有交集，右端点较小的那个区间的右端点必然处于两个区间的交集内。
 * 下面证明这样选择的点是最少的。我们知道，每次需要选择一个新的点的时候都有当前遍历到区间的左端点大于上一个被选择区间的右端点，即有多少个点被选择，原来的区间集合就存在多少个互不相交的区间，因此，这样选择的点数是最少的。
 */
public class 区间选点 {
    public static void main(String[] args) {

    }
}
