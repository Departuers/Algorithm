package A水题;

/**
 * Basic.HDOJ 1735
 * https://blog.csdn.net/V5ZSQ/article/details/48310941
 * Tom把墨水泼到Jerry的作文上
 * 现在Tom只想知道Jerry的作文被“破坏”了多少。Jerry用方格纸来写作文，每行有L个格子。（左图显示的是L = 10时的一篇作文，’X’表示该格有字，该文有三个段落）
 * 右图显示的是浸水后的作文 ,’O’表示这个位置上的文字已经被破坏。可是Tom并不知道原先哪些格子有文字，哪些没有，他唯一知道的是原文章分为M个段落，
 * 并且每个段落另起一行，空两格开头，段落内部没有空格（注意：任何一行只要开头的两个格子没有文字就可能是一个新段落的开始，例如右图中可能有4个段落）
 * Tom想知道至少有多少个字被破坏了，你能告诉他吗？
 * <p>
 * Input
 * 多组用例，每组用例第一行为三个整数n,l和m分别表示行数，每行字数以及段数，之后为以n*l矩阵表示这张作文纸，以文件尾结束输入
 * Output
 * 对于每组用例，输出与至少被破坏的字数
 * Sample Input
 * 10 10 3 依次作文行数,每行多少格子,作文段落数
 * 0 0 0 1 1 1 0 1 1 0
 * 1 1 0 0 0 1 1 1 0 0
 * 0 0 1 1 0 0 1 1 1 1
 * 1 1 1 1 1 1 1 1 1 1
 * 1 0 1 0 1 1 1 0 0 0
 * 1 1 0 0 1 1 1 1 1 1
 * 1 1 1 1 1 1 1 0 0 0
 * 0 0 1 1 1 1 1 1 1 1
 * 1 1 1 1 1 1 1 1 1 1
 * 0 0 0 0 1 1 1 1 1 0
 * Sample Output
 * 19
 * Solution
 * 如果某行有成为一段首行的“潜质”，即此行前两格为0的话，那么其上一行的末尾0就可以当做没有字，
 * 因此我们首先统计所有被破坏的字数ans，然后减去2*m(每段前两格没有字)，
 * 之后统计每个可能作为段首行的行前一行末尾0的个数，对其排序后选取前m-1个从ans中减掉，
 * 然后再减去最后一行末尾0的个数(最后一行必然是作为最后一段的最后一行)即可
 */
public class HDOJ字数统计1735 {
    public static void main(String[] args) {

    }

    public static int Word(int n, int l, int m, int[][] arr) {
        return 1;
    }
}
