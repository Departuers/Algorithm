###动态规划(打表)自底向上
本质是暴力加上记忆化
```
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
注意：给定 n 是一个正整数。
给出1-5阶楼梯的走法
5              4           3         2     1

1 1 1 1 1     1 1 1 1     1 1 1            1
1 2  1 1      1 2 1                 1 1 
1 1 2 1       1 1 2       1 2
1 1 1 2       2 1 1       2 1
1 2 2         2 2                    2
2 2 1
2 1 2
2 1 1 1

对比1和2,来推导3
 3        2     1  
1 1 1           1(+2)
         1 1(+1)
1 2
2 1      2(+1)

对比2和3,来推导4,需要再走两步或者一步
   4          3         2
1 1 1 1     1 1 1(+1)        
1 2 1                  1 1(+2)
1 1 2       1 2(+1)
2 1 1       2 1(+1)
2 2                     2(+2)

对应起来:可知dp[i] = dp[i - 1] + dp[i - 2]
dp[i]语义就是走i阶楼梯能有多少种选择

大白话:把已知的数据存在数组里,作为基本条件,然后再根据数组语义找出dp方程,
也就是前面得到的答案可以推出后面的答案

解释一下子数组（子串）和子序列的区别，你可以看看下面这个例子：
输入数组：[1,2,3,4,5,6,7,8,9]
子数组：[2,3,4], [5,6,7], [6,7,8,9], ...
子序列：[1,5,9], [2,3,6], [1,8,9], [7,8,9], ...
可以看到的是，子数组必须是数组中的一个连续的区间，而子序列并没有这样一个要求。
你只需要保证子序列中的元素的顺序和原数组中元素的顺序一致即可，例如，在原数组中，元素 1 出现在元素 9 之前，那么在子序列中，如果这两个元素同时出现，那么 1 也必须在 9 之前。
不知道你有没有发现，这里的子数组的问题和我们前面提到的矩阵类动态规划的分析思路很类似，只需要考虑当前位置，以及当前位置和相邻位置的关系。
通过这样的分析就可以把之前讲的内容和今天要介绍的内容关联起来了，相比矩阵类动态规划，序列类动态规划最大的不同在于，对于第 i 个位置的状态分析，它不仅仅需要考虑当前位置的状态，还需要考虑前面 i - 1 个位置的状态，这样的分析思路其实可以从子序列的性质中得出。
对于这类问题的问题拆解，有时并不是那么好发现问题与子问题之间的联系，但是通常来说思考的方向其实在于 寻找当前状态和之前所有状态的关系，我们通过几个非常经典的动态规划问题来一起看看。
https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247486936&idx=1&sn=27ec53c1463384edeeee138db23c1c7d&chksm=fa0e6259cd79eb4f240786ad7c00dcd0ed39ad68fd62b72e15d6a8ee0ecbd26b6250ab3b1171&scene=21#wechat_redirect

矩阵类动态规划，也可以叫做坐标类动态规划，一般这类问题都会给你一个矩阵，矩阵里面有着一些信息，然后你需要根据这些信息求解问题。
其实 矩阵可以看作是图的一种，怎么说？你可以把整个矩阵当成一个图，
矩阵里面的每个位置上的元素当成是图上的节点，然后每个节点的邻居就是其相邻的上下左右的位置，
我们遍历矩阵其实就是遍历图，在遍历的过程中会有一些临时的状态，也就是子问题的答案，
我们记录这些答案，从而推得我们最后想要的答案。

动态规划,在子问题重叠的情况,不同的子问题具有公共的子子问题
动态规划需要具备最优子结构,重叠子问题
基本条件:开始动态规划的,初值,起始条件
边界:问题的边界,得到有限的结果
动态转移方程(dp方程):问题的每一阶段和下一阶段的关系
问题中的状态必须满足无后效性,以前出现状态和以前状态变化,不会影响将来的变化
一定要想清楚dp数组,索引的语义,以及存储的值的语义

动态规划:当前问题的最优解,不能从上一阶段子问题简单得出,需要前面多阶段
多阶层子问题共同计算出,因此需要保存历史求解过的子问题,及其最优解

本质是递推。核心是找到状态转移的方式，写出dp方程
动态规划方法，代表一类问题的解法(最优子结构or子问题最优性)
的一般解法，是设计方法，或者设计策略，不是一种具体的算法

解决交叉子问题，重叠子问题特别好用。
比如求f(n)需要f(n-1)+f(n-2)
求f(n-1)有需要f(n-2)+f(n-3)
求f(n-2)需要f(n-3)+f(n-4)
分叉出去，会重复求子问题，效率非常低。

形式:记忆型递归 比如二维数组存储
递推  比如(斐波拉切数列)把前两项做滚动更替。

1. 01背包问题
有n个价值和重量分别为wi,vi的物品，从这些物品中挑选出总重量不超过W的物品，
求出所有挑选方案中，总价值最大的那种方案

那些物品只有选和不选。物品是一个整体，称之为01背包问题。
比如:n=4
(m,v){(2,3)(1,2)(3,4)(2,2)}
W=5
输出7     (选择第0,1,3号物品)
w = {2, 1, 3, 2};//重量
v = {3, 2, 4, 2};//价值

1.1 完全背包
N件物品,容量为W的背包,第i件物品重量为Wi,价值为Vi,每件物品有无数个,求装的最大价值
dp[i,j]=max[dp[i,j],dp[i-1,j-k*Wi]+k*Vi]    (k>=0)


2.钢条切割
Serling公司购买长钢条，将其切割为短钢条出售。切割工序本身没有成本支出。公司管理层希望知道最佳的切割方案。
假定我们知道Serling公司出售一段长为i英寸的钢条的价格为pi(i=1,2,…，单位为美元)。钢条的长度均为整英寸。

| 长度i | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
| - | - | - | - | - | - | - | - | - | - |
价格pi | 1 | 5 | 8 | 16 | 10 | 17 | 17 | 20 | 24 | 30 |

钢条切割问题是这样的：给定一段长度为n英寸的钢条和一个价格表pi(i=1,2,…n)，求切割钢条方案，使得销售收益rn最大。
注意，如果长度为n英寸的钢条的价格pn足够大，最优解可能就是完全不需要切割。

3.数学三角形
数字三角形(POJ1163)<br>

在数字三角形中寻找一条从顶部到底边的路径，使得路径上所经过的数字之和最大。<br>
路径上的每一步都只能往左下或 右下走。只需要求出这个最大和即可，不必给出具体路径。<br>
三角形的行数大于1小于等于100，数字为 0 - 99<br>
输入格式：<br>
5 //表示三角形的行数 接下来输入三角形<br>
     7<br>
    3 8<br>
   8 1 0<br>
  2 7 4 4<br>
 4 5 2 6 5<br>
要求输出最大和<br>

思路:因为只能往右下或者左下走,从倒数第二排开始求
比如第四排第一个是2,2和4组,或者和5组,比较谁大

                7+23                上一层选下一层的左下或者右下最大的那一个
            3+20    8+13            
        8+12    1+12     10
    5+2     7+5     4+6     4+6

dp[0][0]就是最大值
从倒数第二排开始打表,

还可以使用滚动数组,一维数组

3.有n个石子,A,B轮流取石子,最少一个最多两个,取最后一个的人赢
F[i]代表当前状态还剩多少石子,   
F[0]=0           0代表后手赢,因为先手去取石子,石子没有了,代表后手已经石子取完了
F[1]/F[2]=1      这个状态,1代表先手赢,因为他可以取完,谁先手谁赢
对于F[i]来说,能不能让F[i-1]F[i-2]变成一个输的状态,(使F[i-1]=0,F[i-2]=0)
不关心状态是怎么来的,只关心它现在这个状态 

假设有20个石子,你拿到20个的时候赢,你需要让对面拿完剩18个,或者19个,你自己就赢了
