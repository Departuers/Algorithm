###动态规划(打表)
```
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
注意：给定 n 是一个正整数。
给出1-5阶楼梯的走法
5              4           3         2     1

1 1 1 1 1     1 1 1 1     1 1 1            1
1 2  1 1      1 2 1                 1 1 
1 1 2 1       1 1 2       1 2
1 1 1 2       2 1 1       2 1
1 2 2         2 2                    2
2 2 1
2 1 2
2 1 1 1

对比1和2,来推导3
 3        2     1  
1 1 1           1(+2)
         1 1(+1)
1 2
2 1      2(+1)

对比2和3,来推导4,需要再走两步或者一步
   4          3         2
1 1 1 1     1 1 1(+1)        
1 2 1                  1 1(+2)
1 1 2       1 2(+1)
2 1 1       2 1(+1)
2 2                     2(+2)

对应起来:可知dp[i] = dp[i - 1] + dp[i - 2]
dp[i]语义就是走i阶楼梯能有多少种选择

大白话:把已知的数据存在数组里,作为基本条件,然后再根据数组语义找出dp方程,
也就是前面得到的答案可以推出后面的答案

动态规划,在子问题重叠的情况,不同的子问题具有公共的子子问题
动态规划需要具备最优子结构,重叠子问题
基本条件:开始动态规划的,初值,起始条件
边界:问题的边界,得到有限的结果
动态转移方程(dp方程):问题的每一阶段和下一阶段的关系
问题中的状态必须满足无后效性,以前出现状态和以前状态变化,不会影响将来的变化
一定要想清楚dp数组,索引的语义,以及存储的值的语义

动态规划:当前问题的最优解,不能从上一阶段子问题简单得出,需要前面多阶段
多阶层子问题共同计算出,因此需要保存历史求解过的子问题,及其最优解

本质是递推。核心是找到状态转移的方式，写出dp方程
动态规划方法，代表一类问题的解法(最优子结构or子问题最优性)
的一般解法，是设计方法，或者设计策略，不是一种具体的算法

解决交叉子问题，重叠子问题特别好用。
比如求f(n)需要f(n-1)+f(n-2)
求f(n-1)有需要f(n-2)+f(n-3)
求f(n-2)需要f(n-3)+f(n-4)
分叉出去，会重复求子问题，效率非常低。

形式:记忆型递归 比如二维数组存储
递推  比如(斐波拉切数列)把前两项做滚动更替。

1. 01背包问题
有n个价值和重量分别为wi,vi的物品，从这些物品中挑选出总重量不超过W的物品，
求出所有挑选方案中，总价值最大的那种方案

那些物品只有选和不选。物品是一个整体，称之为01背包问题。
比如:n=4
(m,v){(2,3)(1,2)(3,4)(2,2)}
W=5
输出7     (选择第0,1,3号物品)
w = {2, 1, 3, 2};//重量
v = {3, 2, 4, 2};//价值

1.1 完全背包
N件物品,容量为W的背包,第i件物品重量为Wi,价值为Vi,每件物品有无数个,求装的最大价值
dp[i,j]=max[dp[i,j],dp[i-1,j-k*Wi]+k*Vi]    (k>=0)


2.钢条切割
Serling公司购买长钢条，将其切割为短钢条出售。切割工序本身没有成本支出。公司管理层希望知道最佳的切割方案。
假定我们知道Serling公司出售一段长为i英寸的钢条的价格为pi(i=1,2,…，单位为美元)。钢条的长度均为整英寸。

| 长度i | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
| - | - | - | - | - | - | - | - | - | - |
价格pi | 1 | 5 | 8 | 16 | 10 | 17 | 17 | 20 | 24 | 30 |

钢条切割问题是这样的：给定一段长度为n英寸的钢条和一个价格表pi(i=1,2,…n)，求切割钢条方案，使得销售收益rn最大。
注意，如果长度为n英寸的钢条的价格pn足够大，最优解可能就是完全不需要切割。

3.数学三角形
数字三角形(POJ1163)<br>

在数字三角形中寻找一条从顶部到底边的路径，使得路径上所经过的数字之和最大。<br>
路径上的每一步都只能往左下或 右下走。只需要求出这个最大和即可，不必给出具体路径。<br>
三角形的行数大于1小于等于100，数字为 0 - 99<br>
输入格式：<br>
5 //表示三角形的行数 接下来输入三角形<br>
     7<br>
    3 8<br>
   8 1 0<br>
  2 7 4 4<br>
 4 5 2 6 5<br>
要求输出最大和<br>

思路:因为只能往右下或者左下走,从倒数第二排开始求
比如第四排第一个是2,2和4组,或者和5组,比较谁大

                7+23                上一层选下一层的左下或者右下最大的那一个
            3+20    8+13            
        8+12    1+12     10
    5+2     7+5     4+6     4+6

dp[0][0]就是最大值
从倒数第二排开始打表,

还可以使用滚动数组,一维数组

3.有n个石子,A,B轮流取石子,最少一个最多两个,取最后一个的人赢
F[i]代表当前状态还剩多少石子,   
F[0]=0           0代表后手赢,因为先手去取石子,石子没有了,代表后手已经石子取完了
F[1]/F[2]=1      这个状态,1代表先手赢,因为他可以取完,谁先手谁赢
对于F[i]来说,能不能让F[i-1]F[i-2]变成一个输的状态,(使F[i-1]=0,F[i-2]=0)
不关心状态是怎么来的,只关心它现在这个状态 

假设有20个石子,你拿到20个的时候赢,你需要让对面拿完剩18个,或者19个,你自己就赢了
