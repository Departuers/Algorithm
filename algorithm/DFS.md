#### DFS(Depth-First-Search)
```
需要穷尽所有可能性
深度优先搜索
关键在于状态转移,天然的递归结构
回溯:递归调用代表开启一个分支,如果希望这个分支返回后某些数据恢复到分支开启之前的状态,以便于重新开始,就要用到回溯技巧
--全排列的交换法,数独,部分和,使用了回溯
剪枝:深搜时,如果已经明确从当前状态,无论如何都不会存在(最优)解,就应该中断往下的搜索这种方法称为剪枝
--数独,部分和使用剪枝

BFS在图论发挥较大作用
例题:
1.数独
```
###2.部分数之和
```
给定一个数组a，长度为n，判断是否可以从中选择出若干数，使他们的和恰好为K
输入: n=4
a={1,2,4,7}
K=13

输出:Yes{13=2+4+7}
思路:要这个a[0]，这个1，然后把12交给下一次DFS，或者不要这个a[0],把13交给其他元素来凑
平行状态这是

            13 ，cur=0   cur代表找到哪个上面了，a[cur]
        12，cur=1   13，cur=1
    10,cur=2    
  6,cur=3  10,cur=3
一条路走到完，发现没有找到解，回退，一步继续找
状态转移过程中，会产生变化的量，作为递归的变量，并寻找相应出口
```
###3.水洼数目
```
有一个大小为 N*M 的园子，雨后积起了水。八连通的积水被认为是连接在一起的。请求出
园子里总共有多少水洼？（八连通指的是下图中相对 W 的*的部分）
    ***
    *W*
    ***
限制条件
 N, M ≤ 100
 样例:
 输入
    N=10, M=12
园子如下图（'W'表示积水， '.'表示没有积水）

W........WW.
.WWW.....WWW
....WW...WW.
.........WW.
.........W..
..W......W..
.W.W.....WW.
W.W.W.....W.
.W.W......W.
..W.......W.

输出 3
一个点八个方向，寻找联通
          OOO 
          OWO 
          OOO 

        OOOO
        OWWO
        OOOO
如果一个点是水洼,往右找,又找到了水洼,不能再往左找了,会形成死循环
新水洼的八个方向与前一个水洼有重叠的部分
不适合使用迭代,因为不知道要走多少次
使用DFS较为简便
转移到下一个状态之后,下一个状态又朝着八个状态走,有可能又回到原来的状态
走完一个点就把这个点的水洼变成没有积水的地方
```
###4.n皇后问题
```
在一个n*n的棋盘上面放n个皇后,每行,每列,每条对角线上都只能有一个皇后
n=3的时候是无解的,
NOO
OON          N代表皇后,第二行的皇后和第三行的皇后冲突
ONO

ONO
OON          N代表皇后,第二行的皇后怎么放和第一行的皇后冲突
ONO

OON
NOO          N代表皇后,第二行的皇后和第三行的皇后冲突
ONO

N=4,有4个皇后只有2种摆法
一直在变,只能用DFS枚举所有状态,但可以提前剪枝,很难把这个问题用迭代模拟,
思路:每一行只能放一个皇后,每次只放一个皇后
一行,一列一个对角线只能有一个皇后
每一次都是处理一个新行,不用判断行,判断列也比较简单,主要是判断对角线
1,1     1,2     1,3     1,4
2,1     2,2     2,3     2,4
3,1     3,2     3,3     3,4
4,1     4,2     4,3     4,4

判断对角线:比如3,2的对角线,与它处在同一条主对角线,他们之差相同
比如,3-2=1  跟它同一条对角线的,2,1也是,2-1=1
与3,2处在同一条次对角线,他们之和相同
比如,3+2=5,跟它同一条对角线的,2+3=5,1+4=5
他们处于同一条对角线,这样判断比较简便

```
###5.素数环
```
输入正整数n，对1-n进行排列，使得相邻两个数之和均为素数，
输出时从整数1开始，逆时针排列。同一个环应该恰好输出一次
n<=16

如输入6
输出:
1   4   3   2   5   6
1   6   5   2   3   4
暴力生成全排列，进行判断,太麻烦,要使用DFS,提前剪枝
参数:素数环有几个元素,存储素数环元素的辅助数组,变化的数组下标
DFS搜索过程中变化的cur,也就是数组下标,初始化为1,因为第一个固定为1,只能从第二个开始
每次进入下一层递归,判断一下在素数环中,数字有没有出现过,跟上一个元素加上是不是素数

```
###6.困难的串
```
问题描述:如果一个字符串包含两个相邻的重复子串，则称它为容易的串，其他串称为困难的串,
如:BB，ABCDACABCAB,ABCDABCD都是容易的，A,AB,ABA,D,DC,ABDAB,CBABCBA都是困难的。

输入正整数n,L，输出由前L个字符(大写英文字母)组成的，求字典序第n小的困难的串。
例如，当L=3时，前7个困难的串分别为:
A,AB,ABA,ABAC,ABACA,ABACAB,ABACABA
n指定为4的话,输出ABAC
                {}
            A
         A     B
                  A