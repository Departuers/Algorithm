#### DFS(Depth-First-Search)
```
需要穷尽所有可能性
深度优先搜索
关键在于状态转移,天然的递归结构

BFS在图论发挥较大作用
例题:
1.数独

2.部分数之和
给定一个数组a，长度为n，判断是否可以从中选择出若干数，使他们的和恰好为K
输入: n=4
a={1,2,4,7}
K=13

输出:Yes{13=2+4+7}
思路:要这个a[0]，这个1，然后把12交给下一次DFS，或者不要这个a[0],把13交给其他元素来凑
平行状态这是

            13 ，cur=0   cur代表找到哪个上面了，a[cur]
        12，cur=1   13，cur=1
    10,cur=2    
  6,cur=3  10,cur=3
一条路走到完，发现没有找到解，回退，一步继续找
状态转移过程中，会产生变化的量，作为递归的变量，并寻找相应出口

3.水洼数目
有一个大小为 N*M 的园子，雨后积起了水。八连通的积水被认为是连接在一起的。请求出
园子里总共有多少水洼？（八连通指的是下图中相对 W 的*的部分）
    ***
    *W*
    ***
限制条件
 N, M ≤ 100
 样例:
 输入
    N=10, M=12
园子如下图（'W'表示积水， '.'表示没有积水）

W........WW.
.WWW.....WWW
....WW...WW.
.........WW.
.........W..
..W......W..
.W.W.....WW.
W.W.W.....W.
.W.W......W.
..W.......W.

输出 3
一个点八个方向，寻找联通


5.素数环
输入正整数n，对1-n进行排列，使得相邻两个数之和均为素数，
输出时从整数1开始，逆时针排列。同一个环应该恰好输出一次
n<=16

如输入6
输出:
1   4   3   2   5   6
1   6   5   2   3   4
暴力生成全排列，进行判断

6.困难的串
问题描述:如果一个字符串包含两个相邻的重复子串，则称它为容易的串，其他串称为困难的串,
如:BB，ABCDACABCAB,ABCDABCD都是容易的，A,AB,ABA,D,DC,ABDAB,CBABCBA都是困难的。

输入正整数n,L，输出由前L个字符(大写英文字母)组成的，字典序第n小的困难的串。
例如，当L=3时，前7个困难的串分别为:
A,AB,ABA,ABAC,ABACA,ABACAB,ABACABA
n指定为4的话,输出ABAC