package greedy;

import java.util.Scanner;

/**
 * 有N堆纸牌,编号分别为1,2..N,每堆上有若干张,但纸牌总数必为N的倍数,可以在任一堆上取若干张纸牌,然后移动
 * 移动规则为:在编号为1的堆上取牌,只能移动到编号为2的堆上,在编号为N的堆上取的牌,只能移动到编号为N-1的堆上
 * 在其他堆上取的纸牌,可以移到相邻左边或者右边的堆上
 * 现在要求找出一种移动方法,用最少的移动次数使堆上纸牌数都一样多
 * 例如:N=4
 * 4堆纸牌分别为: ①9  ②8  ③17  ④6
 * 移动三次可达到目的
 * 从3取牌4张到4(9,8,13,10)
 * 从3取牌3张到2(9,11,10,10)
 * 从2取牌1张到1(10,10,10,10)
 * 输入:N(N堆纸牌,1<=N<=100)
 * 之后N排,输入A1,A2...AN,每堆牌的初始数
 * 输出:所有堆均达到相等的最小移动次数
 * <p>
 * 思路:最直观的想法是从所有牌数中找到最多的一堆,然后往小的牌堆上移动,一直到所有的牌相等,
 * 但不知道往哪个方向移动才能使移动次数最少
 * a[i]为第i堆纸牌的张数,ave为均分过后每堆纸牌的张数,ans为最小移动次数
 * 按照由左而右的顺序移动纸牌,若第i堆纸牌的张数a[i]超出平均值,则移动一次(ans+1)
 * 将超出部分留给下一堆,即第i+1堆的纸牌张数增加a[i]-ave,若第i堆纸牌的张数a[i]少于平均值,则移动一次(ans+1)
 * 由下一堆补充不足部分,既第i+1堆的纸牌张数减少ave-a[i]
 * 在从第i+1堆取出纸牌补充到第i堆过程中,可能会出现i+1堆的纸牌数小于0(a[i+1]-(ave-a[i])<0)的情况,但纸牌的总数是n的倍数
 * 因此后面的堆会补充第i+1堆ave-a[i]-a[i+1]+ave张纸牌使其达到均分的要求
 *
 * 例如1  2  27 这三堆,
 * 从第二堆移动9张到第一堆 (10,-7,27)
 * 从第三堆移动17张到第二堆(10,10,10)
 * 只改变了移动顺序,移动次数不变,牌数不够可以"借",多了往右边给
 * 该问题求解的关键在于贪心,从左到右让每堆牌向平均数靠拢,但负数的牌也可以移动才是最关键的
 *
 */
public class 均分纸牌 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int sum = 0, step = 0;
        int N = sc.nextInt();
        int tem[] = new int[N];
        for (int i = 0; i < N; i++) {
            tem[i] = sc.nextInt();
            sum += tem[i];
        }
        int ave = sum / N;
        for (int i = 0; i < N; i++) {
            int t = 0;
            if (tem[i] != ave) {
                t = tem[i] - ave;
                tem[i + 1] += t;
                step++;
            }
        }
        System.out.println(step);
    }

}
