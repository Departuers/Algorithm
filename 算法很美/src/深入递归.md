##双管齐下解递归(recursion)
####自下而上的递归（递推，数学归纳，动态规划）
"逐步生成结果类"，类问题之数值型
还有非数值型
```
--解决简单情况下的问题
--推广到稍复杂情况下的问题
--如果递推次数很明确，用迭代循环
--如果有封闭形式，可以直接求解

数学归纳中有基本条件。比如斐波那契数列，需要有前两个数作为基本条件来推出第三个数



为什么写成递归
递归有更强的表达力，但多路基本效率低到恐怖，重复求子问题效率很低

分治法{
      分解    直观
      DFS.递归
      合并
}
自上而下:比如快排选一个数字，
比它小的放在它左边，比它大的放在右边

f(n)->f(n-1)->f(n-2)->f(n-3)
从上到下是现象
从下到上是本质
实质上是下面那条线的小规模问题逐步生成大规模问题

递归会在栈内存里面开临时变量，保存方法的状态，一步一步走下去，最后回溯
用循环节约空间,速度更快

例子
--1.上楼梯
思路:自下而上去递推
开始想的特别小后面去找规律
楼梯      走法
 1        1
 2        2
 3        4
 4        7    （1+2+4）
 5        13   （2+4+7）

比如走四楼，走一步，剩三步，3步有4种走法，
走两步，剩2步，2步有2种走法，走三步，剩一步
一步只有一种走法，f(4)=f(3)+f(2)+f(1)

规律:f(n)=f(n-1)+f(n-2)+f(n-3)

--2.机器人走方格
给定有一个X*Y的网格。一个机器人只能走格点，且只能向右或者向下走，从左上角走到右下角
请设计一个算法。计算机器人有多少种走法，[X+Y<=12]

X       Y     走法
1       1      1    
1       2      1    x为1的时候，y为多少都只有一种走法
2       1      1    y为1的时候，x为多少只有一种走法
2       2      2
3       2      3   看不出来
2       3      3
3       3      6         
```
![](https://note.youdao.com/yws/public/resource/f203939d06b267a17218f976ad641e71/xmlnote/5F956A52C7094DE6BC8491AED11F86D7/2609)
```
机器人题递推公式f(x,y)=f(x,y-1)+f(x-1,y)
2个变量，由x和y共同决定走法的数量
所以使用二维数组存储

相比走楼梯:f(n)=f(n-1)+f(n-2)+f(n-3)
一个值决定另一个值，n确定，n-1就确定

--3.硬币表示(动态规划)子问题划分

假设有1元，2元，5元，10元，20元，50元，100元，200元
用给定硬币构成一个数值n
假如n=200,3*1+1*2+5+2*20+50+100
问一共有多少种可能的组合方式

变种:1分，2分，5分的硬币三种，问组合成1角，共有多少种组合(暴力循环解决)
1*x+2*y+5*z=10

变种:有1分，2分，5分，10分，四种硬币，
每种硬币无限，给定n分钱，有多少种组合可以组合成n分钱

思路:比如4只有一种组合。
```
###"逐步生成结果类"，类问题之非数值型
```
1.合法括号
实现一种算法:打印出n对括号的所有有效组合
如:输入3
((()))  (()()) (())() ()(()) ()()()
一生三，放进set里面去重
新增的括号可以放在左边，右边，里面
n   |  组合
1      ()
2      (()) ()()
3     ()()()  
```
###子集
```
逐步生成
编写一个方法，确定某集合的所有子集。
{A,B,C}  有限集合
{A} {B} {C} {A,B} {A,C} {B,C} {A,B,C}自身也是自身的子集

C3/1  C3/2  C3/3
子集生成就是选和不选的问题，要或者不要,要或者不要都是它的子集
这个平行状态是个集合，每一个状态又是一个集合。
Set<Set<String>>

从没有元素开始推
                       { }
          {A}                        {}
      {A}     {A,B}              {B}     {}
  {A}  {A,C} {A,B} {A,B,C}   {B}    {B,C}   {C} {}


子集生成之二进制(2^n-1)        
{A,B,C}
子集有2^n个，去掉空集就是(2^n-1)  
比如三个都选就是1 1 1，算上0
对于第一个值，选或者不选。
对于第二个值，选或者不选。
对于第三个值，选或者不选。
会形成一个选择树
去掉空集就是2^n-1
从1-2^n-1(去掉空集)把其中的二进制写出来
0   0   1
0   1   0
0   1   1
1   0   0
1   0   1
1   1   0
1   1   1
C   B   A
0代表不选，1代表选。映射成A，B，C
所以要生成子集的源数组，需要按字典序倒序排列
for(1 -> 2^n-1 )
{
list.add(对应元素)
}
```
### 全排列
```
全排列(N!)
全排列就没有要和不要的概念，全都要，对排列顺序有要求
如果有N个元素，那么有N!种排列方式
某一位上，选谁的概念。
{A,B,C}的全排列
{A,B,C}     {A,C,B}
{B,A,C}     {B,C,A}
{C,A,B}     {C,B,A}
规律:第一位有3个选择，第二位有2个选择，第一位只有一个选择
3*2*1=6

整体上来说N!比2^n-1增长速度快
在4的时候，N!就超过2^n-1，超过子集
增量构造，(前缀法)
1           {A}
2     {B A}     {A  B}      把B放在A的左边，右边
3   {C,B,A}     {C,A,B}   把C放在前一排,每个小集合的左边，右边，中间
    {B,A,C}     {B,C,A}   比如把C放在第二排小集合的左边。
    {A,C,B}     {A,B,C}     
代码细节需要深刻理解

回溯   (交换法)    全排列
{A,B,C}  全排列就是交换顺序，得到所有的排列方式
把每一个元素都放到第一个，
                          {}            
          A[B,C]        B[A,C]       C[A,B]       右边[]中的元素代表这条支路还剩的元素       
       B[C]   C[B]    A[C]  C[A]    A[B]   B[A]
      ABC     ACB     BAC   BCA     CAB     CBA
这种方法使用递归，若有N个元素，就有N路递归，每个递归深度为N
先纵后横
数组是共享的，因为不停的交换，已经乱了，所以每棵子树遍历结束，要回溯
回溯求全排列需要多路分支，多路递归


1.例题: n个数的排列组合找出字典序的第K个排列
有没有排列方式是按字典序排列的，只要第K个排列，只寻找到第K个

思路:首先字符串源串是有序的。
(这种思路有重复字符需要特殊处理:当判断字符可用时，需要在前缀中出现的次数<在数组中出现的次数，才认为可用)
确定第一个前缀，确定第二个前缀
            {A}  {AB}  {ABC}   这样找前缀。找到末尾，就开始计数了，计数到K，就返回
{A,B,C}     {A}  {AC}  {ACB}   每次找剩余字典序小的字符，作为前缀，增长前缀
            {B}  {BA}  {BAC}
            {B}  {BC}  {BCA}
            {C}  {CA}  {CAB}
            {C}  {CB}  {CBA}
每次加入，剩余元素中，字典序最小的数，每次确定一个前缀
这样产生的ArrayList就是按字典序排列的
出口:如果前缀的长度==源字符数组长度，就代表完成了一次排列，当找到第K个，就退出exit

```
###封闭形式的直接解
```
如果有封闭形式，可以通过数学归纳直接求解

汉诺塔的移动次数，
f(n)=2f(n-1)+1          通过递推式来算
找规律
1   1
2   3
3   7
n   2^n-1
封闭形式f(n)=2^n-1      通过数学归纳来算

那么由此可得f(n-1)=2^(n-1)-1
把f(n-1)代入f(n)=2f(n-1)+1可得2(2^(n-1)-1)+1化简可得2^n-1
所以f(n)=2^n-1

斐波拉切数列的第n项(需要用到线性代数)

上楼梯(每次只能走1步，或者走2步，有多少种走法)(需要用到线性代数)

上楼梯变型:每次可以走1-N步，有N阶楼梯,无论有多少阶都能一次走完,问有多少种走法
N       r
1       1
2       2
3       4
4       8
5       16     就是前面所有数之和+1
n      2^(n-1)      2的(n-1)次幂

牢牢抓住，逐步形成，逐步类推，从小到大，由简到繁
```