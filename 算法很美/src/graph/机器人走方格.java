package graph;

import java.util.Arrays;

/**
 * LeetCode 第 62 号问题:机器人走方格
 * https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247486923&idx=2&sn=6c1c8aeb4db68522e67ddf8c1e933660&chksm=fa0e624acd79eb5cdb410808921609a830b9b9221e813e4eb89cf551ca48f317668d44b095d2&scene=21#wechat_redirect
 * 矩阵类动态规划，也可以叫做坐标类动态规划，一般这类问题都会给你一个矩阵，矩阵里面有着一些信息，然后你需要根据这些信息求解问题。
 * 其实 矩阵可以看作是图的一种，怎么说？你可以把整个矩阵当成一个图，
 * 矩阵里面的每个位置上的元素当成是图上的节点，然后每个节点的邻居就是其相邻的上下左右的位置，
 * 我们遍历矩阵其实就是遍历图，在遍历的过程中会有一些临时的状态，也就是子问题的答案，
 * 我们记录这些答案，从而推得我们最后想要的答案。
 * 给定一个矩阵，问有多少种不同的方式从起点(0,0) 到终点 (m-1,n-1)，并且每次移动只能向右或者向下，我们还是按之前提到的分析动态规划那四个步骤来思考一下：
 * <p>
 * 问题拆解
 * 题目中说了，每次移动只能是向右或者是向下，矩阵类动态规划需要关注当前位置和其相邻位置的关系，对于某一个位置来说，经过它的路径只能从它上面过来，或者从它左边过来，
 * 因此，如果需要求到达当前位置的不同路径，我们需要知道到达其上方位置的不同路径，以及到达其左方位置的不同路径
 * 状态定义
 * 矩阵类动态规划的状态定义相对来说比较简单，只需要看当前位置即可，问题拆解中，我们分析了当前位置和  其邻居的关系，提到每个位置其实都可以算做是终点，状态表示就是 “从起点到达该位置的不同路径数目”
 * 递推方程
 * 有了状态，也知道了问题之间的联系，其实递推方程也出来了，就是
 * dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
 * 考虑状态数组的初始化问题，对于上边界和左边界的点，因为它们只能从一个方向过来，需要单独考虑，比如上边界的点只能从左边这一个方向过来，左边界的点只能从上边这一个方向过来，它们的不同路径个数其实就只有 1，提前处理就好。
 */
public class 机器人走方格 {
    public static void main(String[] args) {
       // System.out.println(Jqr(7, 3));
        int[][] arr = new int[3][4];
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[0].length; j++) {
                if (Math.random() * 15 < 3)
                    arr[i][j] = 1;
            }
        }
//        int[][] test={{0,0,0},{0,1,0},{0,0,0}};
        System.out.println(ZhangAi(arr));
        for (int[] ints : arr) {
            System.out.println(Arrays.toString(ints));
        }

    }

    /**
     * LeetCode 第 63 号问题,机器人走方格
     * 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
     * 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
     * 问总共有多少条不同的路径？
     * <p>
     * 具体思路:根据走楼梯推理得到:分解为简单的重复子问题,达到最优子结构
     * 机器人从左上角到达(m,n),由于只能往右或者往下走,寻找倒数第二步与最后一步的关系
     * 倒数第二步,可能走到(m-1,n)或者走到(m,n-1),走到这里再走一步就能到达右下角
     * 机器人到达每个点都可以看做终点,由于是路径总数,则dp方程为
     * dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
     * dp数组语义就是,dp[i][j]代表机器人从左上角走到(i,j)有多少种方式
     * 所以基本条件就是,当只有1行的时候,只有一种走法
     * 当只有一列的时候也只有一种走法
     *
     * @param m 长度
     * @param n 宽度
     * @return 路径总数
     */
    public static int Jqr(int m, int n) {
        int[][] dp = new int[m][n];

        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }//基本条件:当只有一列的时候,只有一种走法
        for (int i = 0; i < n; i++) {
            dp[0][i] = 1;
        }//基本条件:当只有一行的时候,只有一种走法

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];//数组从0开始
    }

    /**
     * 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
     * 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
     * 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
     * 输入:
     * [
     * [0,0,0],
     * [0,1,0],
     * [0,0,0]
     * ]
     * 输出: 2
     * 解释:
     * 3x3 网格的正中间有一个障碍物。
     * 从左上角到右下角一共有 2 条不同的路径：
     * 1. 向右 -> 向右 -> 向下 -> 向下
     * 2. 向下 -> 向下 -> 向右 -> 向右
     * 在上面那道题的基础上，矩阵中增加了障碍物，这里只需要针对障碍物进行判断即可，
     * 如果当前位置是障碍物的话，状态数组中当前位置记录的答案就是0，
     * 也就是没有任何一条路径可以到达当前位置，
     * 除了这一点外，其余的分析方法和解题思路和之前 一样 。
     *
     * @param arr 包含障碍的数组
     */
    public static int ZhangAi(int[][] arr) {
        if (arr.length == 0 || arr[0].length == 0) {
            return 0;
        }//如果没有网格,m和n都是0,没有输入,直接返回0
        if (arr[0][0] == 1) return 0;//如果左上角,第一个网格就是障碍物,那一条路也没有
        int m = arr.length, n = arr[0].length;
        int[][] dp = new int[m][n];
        dp[0][0] = 1;

        for (int i = 1; i < m; i++) {
            dp[i][0] = arr[i][0] == 1 ? 0 : dp[i - 1][0];//
        }//初始化第一列,如果在源数组中该点为1,就说明是障碍,给障碍赋值为0,也就是无法到达
        for (int i = 1; i < n; i++) {
            dp[0][i] = arr[0][i] == 1 ? 0 : dp[0][i - 1];
        }//同理初始化第一行

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = arr[i][j] == 1 ? 0 : dp[i - 1][j] + dp[i][j - 1];
            }
        }
        for (int[] ints : dp) {
            System.out.println(Arrays.toString(ints));
        }
        return dp[m - 1][n - 1];
    }

}
